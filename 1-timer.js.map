{"version":3,"file":"1-timer.js","sources":["../src/js/1-timer.js"],"sourcesContent":["'use strict';\n\n// Підключаємо бібліотеку \"flatpickr\" - бібліотека для вибору дати й часу, разом із її CSS-стилями, щоб календар виглядав гарно.\nimport flatpickr from 'flatpickr';\nimport 'flatpickr/dist/flatpickr.min.css';\n\n// Підключаємо бібліотеку \"iziToast\" - бібліотека для виведення повідомлень, разом із її стилями для коректного відображення сповіщень.\nimport iziToast from 'izitoast';\nimport 'izitoast/dist/css/iziToast.min.css';\n\n// Отримуємо доступ до HTML-елементів на сторінці за допомогою document.querySelector\nconst startButton = document.querySelector('button[data-start]');\nconst dateTimePicker = document.querySelector('#datetime-picker');\nconst daysEl = document.querySelector('span[data-days]');\nconst hoursEl = document.querySelector('span[data-hours]');\nconst minutesEl = document.querySelector('span[data-minutes]');\nconst secondsEl = document.querySelector('span[data-seconds]');\n\n// Ініціалізуємо змінну userSelectedDate значенням null. Це потрібно для того, щоб у подальшому зберегти дату й час, вибрані користувачем.\nlet userSelectedDate = null;\n\n// Вимикаємо кнопку startButton (задаємо startButton.disabled = true;), щоб вона була неактивною на початку. Це необхідно для того, щоб користувач не зміг запустити таймер до вибору коректної дати.\nstartButton.disabled = true;\n\n// Створюємо об'єкт options для налаштувань бібліотеки flatpickr, щоб налаштувати вибір дати та часу:\nconst options = {\n  enableTime: true, // enableTime: дає можливість вибирати час, а не тільки дату.\n  time_24hr: true, // time_24hr: використовує 24-годинний формат часу.\n  defaultDate: new Date(), // defaultDate: задає початкову дату за допомогою new Date(), щоб вона збігалася з поточним моментом часу.\n  minuteIncrement: 1, // minuteIncrement: встановлює крок вибору хвилин на 1, щоб точніше контролювати час.\n\n  // Оголошуємо метод onClose - він викликається, коли користувач закриває вибір дати:\n  onClose(selectedDates) {\n    console.log(selectedDates); // selectedDates - масив вибраних дат, де selectedDates[0] є першим (і єдиним) вибраним значенням.\n    const selectedDate = selectedDates[0]; // selectedDate: змінна, яка зберігає значення вибраної дати.\n\n    // Робимо валідацію вибраної дати\n    // Перевіряємо, чи вибрана дата (selectedDate) знаходиться в майбутньому щодо поточного часу new Date():\n    if (selectedDate <= new Date()) {\n      // Якщо дата в минулому або збігається з поточним моментом, виводимо повідомлення за допомогою iziToast.error\n      iziToast.error({\n        title: 'Error',\n        message: 'Please choose a date in the future',\n        position: 'topRight',\n      });\n      startButton.disabled = true; // вимикаємо кнопку startButton\n    } else {\n      // Якщо дата коректна (в майбутньому), зберігаємо її у змінну userSelectedDate і активуємо кнопку startButton для запуску таймера.\n      userSelectedDate = selectedDate;\n      startButton.disabled = false;\n    }\n    // Таким чином, options налаштовує flatpickr і додає перевірку дати, щоб таймер можна було запустити лише для майбутнього часу.\n    console.log(selectedDate);\n  },\n};\n\n// Викликаємо flatpickr на елементі #datetime-picker\nflatpickr('#datetime-picker', options); // тут ми ініціалізуємо вибір дати й часу, передаючи в нього елемент #datetime-picker як перший аргумент, а об'єкт options як другий. Це дозволяє налаштувати календар відповідно до раніше заданих параметрів.\n\n// Додаємо слухач події click для кнопки startButton\nstartButton.addEventListener('click', handleStart); // коли користувач натискає кнопку startButton, викликається функція handleStart, яка запускає таймер.\n\n// Створюємо функцію-обробник handleStart\nfunction handleStart() {\n  // Перевірка - якщо userSelectedDate не встановлено (тобто є null або undefined), функція завершиться (return;), не виконуючи подальший код.\n  if (!userSelectedDate) {\n    return;\n  }\n\n  // Вимикаємо кнопку startButton і поле dateTimePicker\n  startButton.disabled = true; // блокуємо кнопку Start, щоб запобігти повторному натисканню під час роботи таймера.\n  dateTimePicker.disabled = true; // блокуємо елемент (input), щоб запобігти зміні вибору дати\n\n  // Ініціалізуємо setInterval для запуску таймера, intervalId - цифровий ідентифікатор інтервала\n  // setInterval створює інтервал, який виконує вкладену функцію щосекунди (кожні 1000 мс).\n  const intervalId = setInterval(() => {\n    const currentTime = new Date(); // Оголошуємо змінну currentTime: зберігає поточний момент у змінну\n    const timeLeft = userSelectedDate - currentTime; // Визначаємо змінну timeLeft як різницю між userSelectedDate та currentTime: обчислює кількість мілісекунд, що залишилися до вибраної дати, віднімаючи поточний час від дати, встановленої користувачем.\n\n    // Перевіряємо залишковий час timeLeft: Якщо timeLeft менше або дорівнює 0 (тобто час завершився), ми завершуємо відлік.\n    if (timeLeft <= 0) {\n      clearInterval(intervalId); // Зупиняємо інтервал за допомогою clearInterval: очищає інтервал, щоб припинити повторні виклики функції, зупиняючи таймер.\n\n      // Оновлюємо відображення таймера на 0\n      // Викликаємо updateTimerDisplay і передаємо об'єкт із значеннями { days: 0, hours: 0, minutes: 0, seconds: 0 }, щоб усі показники таймера обнулилися.\n      updateTimerDisplay({ days: 0, hours: 0, minutes: 0, seconds: 0 });\n      dateTimePicker.disabled = false; // Розблоковуємо поле dateTimePicker для нового вибору дати: дозволяє користувачу вибрати нову дату після\n      return; // Завершуємо виконання функції: після очищення інтервалу та обнулення дисплея таймера функція завершує роботу.\n    }\n\n    // Створюємо змінну timeComponents, значенням якої буде виклик функції convertMs\n    // Викликаємо функцію convertMs, передаючи їй значення timeLeft, і зберігаємо результат у timeComponents.\n    const timeComponents = convertMs(timeLeft);\n\n    // Викликаємо функції updateTimerDisplay\n    // Ця функція викликається з параметром timeComponents\n    // timeComponents містить об'єкт, що був отриманий в результаті виклику convertMs(timeLeft), тобто має структуру { days, hours, minutes, seconds }\n    // Коли викликається updateTimerDisplay, функція деструктуризує timeComponents, витягуючи значення днів, годин, хвилин і секунд, і присвоює їх відповідним span-елементам на сторінці.\n    updateTimerDisplay(timeComponents); // цей виклик оновлює відображення таймера на екрані відповідно до залишкового часу\n  }, 1000);\n}\n\n// Створюємо функцію updateTimerDisplay\n// Цей блок коду оновлює таймер на сторінці, відображаючи дні, години, хвилини та секунди у потрібному форматі.\n// Функція приймає об'єкт з параметрами { days, hours, minutes, seconds }, використовуємо деструктуризацію відразу в параметрі функції\n// Цей об'єкт має ту ж структуру, яку повертає функція convertMs\nfunction updateTimerDisplay({ days, hours, minutes, seconds }) {\n  // Використовуємо textContent для оновлення тексту в елементах таймера\n  // Присвоюємо значення відповідним span-елементам (daysEl, hoursEl, minutesEl, secondsEl)\n  // Викликаємо функцію addLeadingZero для кожного значення, щоб забезпечити двозначний формат (наприклад, 05 замість 5)\n  daysEl.textContent = addLeadingZero(days);\n  hoursEl.textContent = addLeadingZero(hours);\n  minutesEl.textContent = addLeadingZero(minutes);\n  secondsEl.textContent = addLeadingZero(seconds);\n}\n\n// Створюємо функцію addLeadingZero, яка приймає число value як аргумент\n// Функція перетворює value на рядок:\n// String(value) - переводить число в рядок, щоб можна було застосувати метод padStart\n// padStart(2, '0') приводить рядок до двозначного формату, додаючи 0 на початок, якщо значення однозначне\nfunction addLeadingZero(value) {\n  return String(value).padStart(2, '0');\n}\n\n// Створюємо функцію convertMs\n// convertMs(ms) приймає кількість мілісекунд ms і перетворює її на окремі одиниці часу (дні, години, хвилини, секунди).\n// Константи для визначення тривалості однієї секунди, хвилини, години та дня (second, minute, hour, day) використовуються для обчислення відповідних компонентів.\nfunction convertMs(ms) {\n  const second = 1000;\n  const minute = second * 60;\n  const hour = minute * 60;\n  const day = hour * 24;\n\n  const days = Math.floor(ms / day); // кількість повних днів у ms (Math.floor(ms / day)).\n  const hours = Math.floor((ms % day) / hour); // кількість повних годин, що залишилися після віднімання днів (Math.floor((ms % day) / hour)).\n  const minutes = Math.floor(((ms % day) % hour) / minute); // кількість повних хвилин, що залишилися після віднімання днів та годин (Math.floor(((ms % day) % hour) / minute)).\n  const seconds = Math.floor((((ms % day) % hour) % minute) / second); // кількість повних секунд, що залишилися після віднімання днів, годин та хвилин (Math.floor((((ms % day) % hour) % minute) / second)).\n\n  // Повертаємо об'єкт з обчисленими компонентами\n  // Цей синтаксис не є деструктуризацією; він лише створює і повертає об'єкт. У цьому випадку { days, hours, minutes, seconds } є скороченим записом для створення об'єкта, де назви полів збігаються з назвами змінних.\n  // Тобто цей рядок еквівалентний: return { days: days, hours: hours, minutes: minutes, seconds: seconds };\n  return { days, hours, minutes, seconds }; // результатом функції є об'єкт, що містить дні, години, хвилини та секунди.\n}\n\n// Коментарі тезово\n// Підсумок коду:\n// 1. Підключення бібліотек:\n// flatpickr: для вибору дати та часу.\n// iziToast: для відображення сповіщень.\n\n// 2. Отримання елементів DOM:\n// Збираємо елементи для кнопки запуску таймера, вибору дати, та для відображення залишкового часу.\n\n// 3. Ініціалізація змінних:\n// userSelectedDate — зберігає дату, вибрану користувачем (ініціалізується значенням null).\n// Кнопка startButton деактивується до вибору коректної дати.\n\n// 4. Конфігурація flatpickr:\n// Налаштовуємо параметри вибору дати/часу, включаючи можливість вибору часу, 24-годинний формат, початкову дату, та крок вибору хвилин.\n// Додаємо валідацію вибраної дати в методі onClose, щоб активувати кнопку лише при виборі майбутньої дати.\n\n// 5. Слухач події:\n// Додаємо обробник подій для кнопки запуску таймера, який викликає функцію handleStart.\n\n// 6. Обробка запуску таймера (handleStart):\n// Перевіряється, чи вибрана дата (userSelectedDate).\n// Блокує кнопку та поле введення.\n// Запускає setInterval, що кожну секунду обчислює залишковий час.\n\n// 7. Обчислення залишкового часу:\n// Перевіряє, чи залишковий час не закінчився.\n// Якщо закінчився — очищає інтервал, обнуляє значення таймера та розблокує поле для вибору нової дати.\n// Викликає convertMs для отримання компонентів часу (дні, години, хвилини, секунди).\n\n// 8. Оновлення відображення таймера:\n// Функція updateTimerDisplay відповідає за оновлення вмісту елементів span на сторінці відповідно до залишкового часу, використовуючи addLeadingZero для форматування.\n\n// 9. Допоміжні функції:\n// addLeadingZero: перетворює значення в рядок з двозначним форматом.\n// convertMs: перетворює мілісекунди в дні, години, хвилини та секунди, повертаючи об'єкт з цими значеннями.\n"],"names":["startButton","dateTimePicker","daysEl","hoursEl","minutesEl","secondsEl","userSelectedDate","options","selectedDates","selectedDate","iziToast","flatpickr","handleStart","intervalId","timeLeft","updateTimerDisplay","timeComponents","convertMs","days","hours","minutes","seconds","addLeadingZero","value","ms"],"mappings":"0IAWA,MAAMA,EAAc,SAAS,cAAc,oBAAoB,EACzDC,EAAiB,SAAS,cAAc,kBAAkB,EAC1DC,EAAS,SAAS,cAAc,iBAAiB,EACjDC,EAAU,SAAS,cAAc,kBAAkB,EACnDC,EAAY,SAAS,cAAc,oBAAoB,EACvDC,EAAY,SAAS,cAAc,oBAAoB,EAG7D,IAAIC,EAAmB,KAGvBN,EAAY,SAAW,GAGvB,MAAMO,EAAU,CACd,WAAY,GACZ,UAAW,GACX,YAAa,IAAI,KACjB,gBAAiB,EAGjB,QAAQC,EAAe,CACrB,QAAQ,IAAIA,CAAa,EACzB,MAAMC,EAAeD,EAAc,CAAC,EAIhCC,GAAgB,IAAI,MAEtBC,EAAS,MAAM,CACb,MAAO,QACP,QAAS,qCACT,SAAU,UAClB,CAAO,EACDV,EAAY,SAAW,KAGvBM,EAAmBG,EACnBT,EAAY,SAAW,IAGzB,QAAQ,IAAIS,CAAY,CACzB,CACH,EAGAE,EAAU,mBAAoBJ,CAAO,EAGrCP,EAAY,iBAAiB,QAASY,CAAW,EAGjD,SAASA,GAAc,CAErB,GAAI,CAACN,EACH,OAIFN,EAAY,SAAW,GACvBC,EAAe,SAAW,GAI1B,MAAMY,EAAa,YAAY,IAAM,CAEnC,MAAMC,EAAWR,EADG,IAAI,KAIxB,GAAIQ,GAAY,EAAG,CACjB,cAAcD,CAAU,EAIxBE,EAAmB,CAAE,KAAM,EAAG,MAAO,EAAG,QAAS,EAAG,QAAS,CAAC,CAAE,EAChEd,EAAe,SAAW,GAC1B,MACD,CAID,MAAMe,EAAiBC,EAAUH,CAAQ,EAMzCC,EAAmBC,CAAc,CAClC,EAAE,GAAI,CACT,CAMA,SAASD,EAAmB,CAAE,KAAAG,EAAM,MAAAC,EAAO,QAAAC,EAAS,QAAAC,CAAO,EAAI,CAI7DnB,EAAO,YAAcoB,EAAeJ,CAAI,EACxCf,EAAQ,YAAcmB,EAAeH,CAAK,EAC1Cf,EAAU,YAAckB,EAAeF,CAAO,EAC9Cf,EAAU,YAAciB,EAAeD,CAAO,CAChD,CAMA,SAASC,EAAeC,EAAO,CAC7B,OAAO,OAAOA,CAAK,EAAE,SAAS,EAAG,GAAG,CACtC,CAKA,SAASN,EAAUO,EAAI,CAMrB,MAAMN,EAAO,KAAK,MAAMM,EAAK,KAAG,EAC1BL,EAAQ,KAAK,MAAOK,EAAK,MAAO,IAAI,EACpCJ,EAAU,KAAK,MAAQI,EAAK,MAAO,KAAQ,GAAM,EACjDH,EAAU,KAAK,MAASG,EAAK,MAAO,KAAQ,IAAU,GAAM,EAKlE,MAAO,CAAE,KAAAN,EAAM,MAAAC,EAAO,QAAAC,EAAS,QAAAC,CAAO,CACxC"}